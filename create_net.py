# -*- coding: utf-8 -*-
"""create_net.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QvGgzbJ_QJV6z711jAIcKi8-d6wx-miX

Due to the complexity of the circuit ODEs and the time-expensive integration required for obtaining (V_LV(ED), V_LV(ES), EF) for any patient, we create here
a neural network (NN) that approximates with high accuracy the values (V_LV(ED), V_LV(ES), EF) for any patient. To do so, we generate a dataset of realistic circuit parameters, 
and train a NN on the given dataset for predicting the V_LV(ED), V_LV(ES) and EF. Steps:
1. Find the optimal range values for each parameter, taking into account pressures and volumes.
2. Save the parameters and the ved, ves for each patient.
3. Create, train and test an NN ('net') for predicting ved, ves in the whole chosen space.

"""

import numpy as np
import torch
from torch.utils import data
from torch.utils.data import DataLoader, Dataset
from torch import nn, optim
import os
from skimage.transform import rescale, resize
import torch.nn.functional as F
from torch.utils.data import Subset
import itertools
from math import prod

import time
from scipy.integrate import odeint #collection of advanced numerical algorithms to solve initial-value problems of ordinary differential equations.
from matplotlib import pyplot as plt
import random
import sys

from google.colab import drive
drive.mount('/content/drive')

"""Define the cardiac ODE system (f has to be changed based on the parameters are fixed, which have to be defined inside of f in order to simplify the rest of the program)"""

### ODE: for each t (here fixed), gives dy/dt as a function of y(t) at that t, so can be used for integrating the vector y over time
#it is run for each t going from 0 to tmax
def heart_ode(y, t, Rs, Rm, Ra, Rc, Ca, Cs, Cr, Ls, Emax, Emin, Tc):
    x1, x2, x3, x4, x5 = y #here y is a vector of 5 values (not functions), at time t, used for getting (dy/dt)(t)
    P_lv = Plv(x1,Emax,Emin,t,Tc)
    dydt = [r(x2-P_lv)/Rm-r(P_lv-x4)/Ra, (x3-x2)/(Rs*Cr)-r(x2-P_lv)/(Cr*Rm), (x2-x3)/(Rs*Cs)+x5/Cs, -x5/Ca+r(P_lv-x4)/(Ca*Ra), (x4-x3-Rc*x5)/Ls]
    return dydt

def r(u):
    if u<0:
        return 0
    else:
        return u

#returns Plv at time t using Elastance(t) and Vlv(t)-Vd=x1
def Plv(x1,Emax,Emin,t, Tc):
    return Elastance(Emax,Emin,t, Tc)*x1

#returns Elastance(t)
def Elastance(Emax,Emin,t, Tc):
    t = t-int(t/Tc)*Tc #can remove this if only want 1st ED (and the 1st ES before)
    tn = t/(0.2+0.15*Tc)
    return (Emax-Emin)*1.55*(tn/0.7)**1.9/((tn/0.7)**1.9+1)*1/((tn/1.17)**21.9+1) + Emin

def f(Tc, start_v, Emax, Emin, Rm, Ra, Vd, N, plotloops):
    startp = 75.
    Rs = 1.0
    Rc = 0.0398
    Ca = 0.08
    Cs = 1.33
    Cr = 4.400
    Ls = 0.0005

    start_pla = float(start_v*Elastance(Emax, Emin, 0, Tc))
    start_pao = startp
    start_pa = start_pao
    start_qt = 0 #aortic flow is Q_T and is 0 at ED, also see Fig5 in simaan2008dynamical
    y0 = [start_v, start_pla, start_pa, start_pao, start_qt]

    t = np.linspace(0, Tc*N, int(60000*N)) #spaced numbers over interval (start, stop, number_of_steps), 60000 time instances for each heart cycle
    #changed to 60000 for having integer positions for Tmax

    sol = odeint(heart_ode, y0, t, args = (Rs, Rm, Ra, Rc, Ca, Cs, Cr, Ls, Emax, Emin, Tc)) #t: list of values

    result_Vlv = np.array(sol[:, 0]) + Vd
    result_Plv = np.array([Plv(v, Emax, Emin, xi, Tc) for xi,v in zip(t,sol[:, 0])])

    ved = sol[(N-1)*60000, 0] + Vd
    ves = sol[200*int(60/Tc)+9000+(N-1)*60000, 0] + Vd
    ef = (ved-ves)/ved * 100.

    minv = min(result_Vlv[(N-1)*60000:N*60000-1])
    minp = min(result_Plv[(N-1)*60000:N*60000-1])
    maxp = max(result_Plv[(N-1)*60000:N*60000-1])

    ved2 = sol[(N-1)*60000 - 1, 0] + Vd
    isperiodic = 0
    if (abs(ved-ved2) > 5.): isperiodic = 1

    if plotloops:
      plt.plot(result_Vlv[(N-2)*60000:(N)*60000], result_Plv[(N-2)*60000:N*60000])
      plt.xlabel("LV volume (ml)")
      plt.ylabel("LV pressure (mmHg)")
      plt.show()

    return ved, ves, ef, minv, minp, maxp, isperiodic

"""Do some testing by varying the intervals, the number of parameters and the number of points:"""

N = 70 # number of cycles to run
ints = [[0.4, 1.7], [0., 280.], [0.5, 3.5], [0.02, 0.1], [0.005, 0.1], [0.0001, 0.25]] #validity interval for each learnable parameter
nvals_pars = [2, 2, 2, 2, 2, 2] #number of values taken from each parameter
vds = np.linspace(4., 25., 15) # Vd volumes taken (not used for the interpolator)

n_pars = len(ints)
n_points = prod(nvals_pars)

pars = []
for i in range(n_pars):
  pars.append(np.linspace(ints[i][0], ints[i][1], nvals_pars[i]))

points = list(itertools.product(*pars))
print(points[0], points[-1])

veds = []
vess = []
redp0 = []
redp1 = []
greenp0 = []
greenp1 = []
i=0

for point in points:
  ved, ves, _, minv, minp, maxp, isperiodic = f(*point, vds[0], N, True) ##recommended to plot the pv loops when building the intervals
  veds.append(ved)
  vess.append(ves)

  if (minp<=0 or minv<=0 or isperiodic==1):
    print("Error: negative volume/pressure or did not reach steady-state: ", point)

  else:
    if (maxp>145. or maxp<80. or minp>14. or minp<2.):
      print("Error: pressure out of normal ranges", point)
      redp0.append(ved)
      redp1.append(ves)
    else: ##in good ranges:
      greenp0.append(ved)
      greenp1.append(ves)

  if i%100==0: print(i, "/", n_points)
  i+=1

#add to the n_points (veds, ves) the possible values of Vd for plotting all the (ved, ves):
for i in range(n_points):
  for vd in vds[1:]: #do not need to add the point ved-4+4=ved since it is already in veds
    veds.append(veds[i] - 4. + vd)
    vess.append(vess[i] - 4. + vd)

    redp0.append(vess[i] - 4. + vd)
    redp1.append(vess[i] - 4. + vd)

    greenp0.append(vess[i] - 4. + vd)
    greenp1.append(vess[i] - 4. + vd)

plt.scatter(veds, vess, color=(220/255, 220/255, 120/255), edgecolors='none', alpha=0.8, label='All points') #yellow
plt.scatter(redp0, redp1, color=(233/255, 116/255, 81/255), label='LV pressures out of range') #red
plt.scatter(greenp0, greenp1, color=(120/255, 200/255, 120/255), label='LV pressures in normal range') #green
plt.legend(loc='upper left', framealpha=1)
plt.xlabel("End-diastolic volume (ml)")
plt.ylabel("End-systolic volume (ml)")
plt.show()

"""Once all the parameters are found, generate and save enough sample points for the interpolation:"""

## rewrite here the definitive intervals, number of parameters and Vd points for the generation of the dataset:
N = 70
ints = [[0.4, 1.7], [0., 280.], [0.5, 3.5], [0.02, 0.1], [0.005, 0.1], [0.0001, 0.25]] #validity interval for each learnable parameter
nvals_pars = [4, 3, 5, 4, 4, 4] #number of values taken from each parameter
vds = np.linspace(4., 25., 15) # Vd volumes taken (not used for the interpolator)

n_pars = len(ints)
n_points = prod(nvals_pars)

pars = []
for i in range(n_pars):
  pars.append(np.linspace(ints[i][0], ints[i][1], nvals_pars[i]))

points = list(itertools.product(*pars))

veds = []
vess = []

redp0 = []
redp1 = []
greenp0 = []
greenp1 = []

i=0

for point in points:
  ved, ves, ef, minv, minp, maxp, isperiodic = f(*point, vds[0], N, False) ##recommended to plot the pv loops when building the intervals
  veds.append(ved)
  vess.append(ves)

  if not (minp<=0 or minv<=0 or isperiodic==1):
    if (maxp>145. or maxp<80. or minp>14. or minp<2.):
      #print("Error: pressure out of normal ranges", point)
      redp0.append(ved)
      redp1.append(ves)
    else: ##in good ranges:
      greenp0.append(ved)
      greenp1.append(ves)

  if i%100==0: print(i, "/", n_points)
  i+=1

#convert into torch tensors:
points2 = torch.tensor(points)
tensor1 = torch.tensor(veds)
tensor2 = torch.tensor(vess)
vedves = torch.stack((tensor1, tensor2), dim=1)
tensor3 = torch.tensor(greenp0)
tensor4 = torch.tensor(greenp1)
vedves_green = torch.stack((tensor3, tensor4), dim=1)

#save points and ved, ves:
output_path = '/content/drive/My Drive/'
file = 'points'
torch.save(points2, os.path.join(output_path,f'{file}.pt'))
file = 'vedves'
torch.save(vedves, os.path.join(output_path,f'{file}.pt'))
file = 'vedves_green'
torch.save(vedves_green, os.path.join(output_path,f'{file}.pt'))
print("Saved")

for i in range(n_points):
  for vd in vds[1:]:
    veds.append(veds[i] - 4. + vd)
    vess.append(vess[i] - 4. + vd)
    redp0.append(veds[i] - 4. + vd)
    redp1.append(vess[i] - 4. + vd)
    greenp0.append(veds[i] - 4. + vd)
    greenp1.append(vess[i] - 4. + vd)

plt.scatter(veds, vess, color=(220/255, 220/255, 120/255), edgecolors='none', alpha=0.8, label='All points') #yellow
plt.scatter(redp0, redp1, color=(233/255, 116/255, 81/255), label='LV pressures out of range') #red
plt.scatter(greenp0, greenp1, color=(120/255, 200/255, 120/255), label='LV pressures in normal range') #green
plt.legend(loc='upper left', framealpha=1)
plt.xlabel("End-diastolic volume (ml)")
plt.ylabel("End-systolic volume (ml)")
plt.show()

"""Once the points and pairs (ved, ves) saved, create and train the interpolator:"""

##in case it is a new session, get the data from the drive:

output_path = '/content/drive/My Drive/'
file = 'points.pt'
pts = torch.load(output_path + file)
print("First and last point:", pts[0], pts[-1]) ##check if all points had been saved
file = 'vedves.pt'
# Load the data points from the file
vedves = torch.load(output_path + file)
x = torch.tensor(pts, dtype = torch.float64)
y = torch.tensor(vedves, dtype=torch.float64)

"""You can also plot again all the (ved, ves) points taking into account the possible Vd's:"""

veds_np = vedves[:, 0].tolist()
vess_np = vedves[:, 1].tolist()

## download too the green points (normal pressures):
file = 'vedves_green.pt' #'vedves.pt'
# Load the data points from the file
vedves_green_tc = torch.load(output_path + file)
veds_green = vedves_green_tc[:, 0].tolist()
vess_green = vedves_green_tc[:, 1].tolist()

for i in range(n_points):
  for vd in vds[1:]:
    veds_np.append(veds_np[i] - 4. + vd)
    vess_np.append(vess_np[i] - 4. + vd)
    veds_green.append(veds_green[i] - 4. + vd)
    vess_green.append(vess_green[i] - 4. + vd)

plt.scatter(veds_np, vess_np, color=(220/255, 220/255, 120/255), edgecolors='none', alpha=0.8, label='All points') #yellow
plt.scatter(veds_green, vess_green, color=(120/255, 200/255, 120/255), label='LV pressures in normal range') #green
plt.legend(loc='upper left', framealpha=1)
plt.xlabel("End-diastolic volume (ml)")
plt.ylabel("End-systolic volume (ml)")
plt.show()

"""Then, create and train the NN-interpolator:"""

n_pars = len(pts[0])
n_neurons = 256 ##in general 256 is enough
lr = 0.01
threshold_train = 1.
threshold_test = 2.
n_epochs = 30000

class Interpolator(nn.Module):
    def __init__(self):
        super().__init__()
        self.fc1 = nn.Linear(n_pars, n_neurons).double()
        self.fc2 = nn.Linear(n_neurons, 2).double()

    def forward(self, z):
        z = torch.relu(self.fc1(z))
        z = self.fc2(z)
        return z

# Initialize the neural network
net = Interpolator()
criterion = nn.MSELoss()
optimizer = torch.optim.Adam(net.parameters(), lr=lr)
losses = []
i = 0

while True:
  for epoch in range(n_epochs):
      # Forward pass
      y_pred = net(x)
      loss = criterion(y_pred, y)

      # Backward pass and optimization
      optimizer.zero_grad()
      loss.backward()
      optimizer.step()

      # Print progress
      if epoch % 5000 == 0:
          print(f'Epoch {epoch}, loss: {loss.item():.4f}')
          losses.append(loss.item())

  if abs(losses[-1] - losses[-2])<5.:
    lr = lr / 10.
    optimizer = torch.optim.Adam(net.parameters(), lr=lr)
  if (i>10 and losses>50.):
    n_neurons += 24
    net = Interpolator()
  if (i>30): break
  if (losses[-1]<threshold_train): break
  i += 1

print("Training error", loss.item())

"""Once training is finished, test it:"""

#for testing the interpolator:
n_test = 50

x_test_tc = torch.zeros(n_test, n_pars)
y_test_tc = torch.zeros(n_test, 2)

for i in range(n_test):
  for j in range(n_pars):
    x_test_tc[i][j] = random.uniform(ints[i][0], ints[i][1])
  print(x_test_tc[i])
  ved, ves, _, _, _, _, _ = f(*(x_test_tc[i].tolist()), vds[0], N, False)
  y_test_tc[i][0] = ved
  y_test_tc[i][1] = ves

error = 0

xt = torch.tensor(x_test_tc, dtype = torch.float64)
yt = torch.tensor(y_test_tc, dtype=torch.float64)

iters=np.linspace(1, n_test, n_test)
#of the tests (given by the real function f):
vedst = []
vesst = []
efst = []
#simulated by net:
simveds=[]
simvess=[]
simefs=[]

for i in range(n_test):
  y_pred = net(xt[i])
  vedsim = y_pred[0].detach().item()
  vessim = y_pred[1].detach().item()

  vedst.append(y_test_tc[i][0])
  vesst.append(y_test_tc[i][1])
  efst.append((y_test_tc[i][0]-y_test_tc[i][1])/y_test_tc[i][0]*100)

  error += abs(vedsim - yt[i][0]) + abs(vessim - yt[i][1])
  simveds.append(vedsim)
  simvess.append(vessim)
  simefs.append((vedsim-vessim)/vedsim*100.)

print("Average test error:", error / (n_test*2))

#save the weights of net if it works well enough:
if (error/(n_test*2)<threshold_test):
  import os
  output_path = '/content/drive/My Drive/'
  file = 'net_weights'
  torch.save(net.state_dict(), os.path.join(output_path,f'{file}__weight.pt'))
  print("Weights saved")

#plot the results: (real vs estimated ved, ves, ef. real: blue, simulated by the net: red)
plt.title("Real vs Simulated VED")
plt.plot(iters, simveds, color='r', label='NN-interpolation')
plt.plot(iters, vedst, color='b', label='True')
plt.ylabel("End-diastolic volume (ml)")
plt.xlabel("Iteration")
plt.legend(loc='upper left', framealpha=1)
plt.show()
plt.title("Real vs Simulated VES")
plt.plot(iters,simvess, color='r', label='NN-interpolation')
plt.plot(iters, vesst, color='b', label='True')
plt.ylabel("End-systolic volume (ml)")
plt.xlabel("Iteration")
plt.legend(loc='upper left', framealpha=1)
plt.show()
plt.title("Real vs Simulated EF")
plt.plot(iters,simefs, color='r', label='NN-interpolation')
plt.plot(iters, efst, color='b', label='True')
plt.ylabel("Ejection fraction (%)")
plt.xlabel("Iteration")
plt.legend(loc='upper left', framealpha=1)
plt.show()
